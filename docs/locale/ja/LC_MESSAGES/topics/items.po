# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2008–2018, Scrapy developers
# This file is distributed under the same license as the Scrapy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Scrapy \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-09-10 09:37+0900\n"
"PO-Revision-Date: 2019-10-02 18:43+0900\n"
"Last-Translator: kuma35\n"
"Language-Team: Japanese\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../../topics/items.rst:5
msgid "Items"
msgstr "アイテム"

#: ../../topics/items.rst:10
msgid ""
"The main goal in scraping is to extract structured data from unstructured"
" sources, typically, web pages. Scrapy spiders can return the extracted "
"data as Python dicts. While convenient and familiar, Python dicts lack "
"structure: it is easy to make a typo in a field name or return "
"inconsistent data, especially in a larger project with many spiders."
msgstr "スクレイピングの主な目標は、非構造化ソース(通常はWebページ)から構造化データを抽出することです。 Scrapyスパイダーは、抽出したデータをPythonの辞書として返すことができます。 Pythonの辞書には便利で使い慣れていますが、構造が欠けています。特に、多くのスパイダーがいる大規模なプロジェクトでは、容易にフィールド名をtypoしたり、矛盾したデータを返しちゃったりします。"

#: ../../topics/items.rst:16
msgid ""
"To define common output data format Scrapy provides the :class:`Item` "
"class. :class:`Item` objects are simple containers used to collect the "
"scraped data. They provide a `dictionary-like`_ API with a convenient "
"syntax for declaring their available fields."
msgstr "一般的な出力データ形式を定義するために、Scrapyは :class:`Item` クラスを提供します。 :class:`Item` オブジェクトは、スクレイピングされたデータを収集するために使用される単純なコンテナです。 これらは、利用可能なフィールドを宣言するための便利な構文を持つ「辞書のようなAPI」(`dictionary-like`_ API)を提供します。"

#: ../../topics/items.rst:21
msgid ""
"Various Scrapy components use extra information provided by Items: "
"exporters look at declared fields to figure out columns to export, "
"serialization can be customized using Item fields metadata, "
":mod:`trackref` tracks Item instances to help find memory leaks (see :ref"
":`topics-leaks-trackrefs`), etc."
msgstr "さまざまなScrapyコンポーネントは、アイテムによって提供される追加情報を使用します。エクスポーターは、宣言されたフィールドを見てエクスポートする列を見つけます。シリアル化は、アイテムのフィールド・メタ・データを使用してカスタマイズできます。 :mod:`trackref` はアイテムのインスタンスを追跡して、メモリ・リーク( :ref:`topics-leaks-trackrefs` 参照)などを見つけるのに役立ちます。"

#: ../../topics/items.rst:32
msgid "Declaring Items"
msgstr "アイテムの宣言"

#: ../../topics/items.rst:34
msgid ""
"Items are declared using a simple class definition syntax and "
":class:`Field` objects. Here is an example::"
msgstr "アイテムは、単純なクラス定義構文と :class:`Field` オブジェクトを使用して宣言します。 以下に例があります::"

#: ../../topics/items.rst:46
msgid ""
"Those familiar with `Django`_ will notice that Scrapy Items are declared "
"similar to `Django Models`_, except that Scrapy Items are much simpler as"
" there is no concept of different field types."
msgstr "`Django`_ に精通している人は、Scrapyアイテムが `Django Models`_ と同様に宣言されていることに気付くでしょう。ただし、異なるフィールド型の概念がないため、Scrapyアイテムははるかに単純です。"

#: ../../topics/items.rst:56
msgid "Item Fields"
msgstr "アイテムのフィールド"

#: ../../topics/items.rst:58
msgid ""
":class:`Field` objects are used to specify metadata for each field. For "
"example, the serializer function for the ``last_updated`` field "
"illustrated in the example above."
msgstr ":class:`Field` オブジェクトは、各フィールドのメタ・データを指定するために使用されます。 たとえば、上記の例で示した ``last_updated`` フィールドのシリアル化関数です。"

#: ../../topics/items.rst:62
msgid ""
"You can specify any kind of metadata for each field. There is no "
"restriction on the values accepted by :class:`Field` objects. For this "
"same reason, there is no reference list of all available metadata keys. "
"Each key defined in :class:`Field` objects could be used by a different "
"component, and only those components know about it. You can also define "
"and use any other :class:`Field` key in your project too, for your own "
"needs. The main goal of :class:`Field` objects is to provide a way to "
"define all field metadata in one place. Typically, those components whose"
" behaviour depends on each field use certain field keys to configure that"
" behaviour. You must refer to their documentation to see which metadata "
"keys are used by each component."
msgstr "あなたは各フィールドに任意の種類のメタ・データを指定できます。 :class:`Field` オブジェクトが受け入れる値には制限はありません。これと同じ理由で、利用可能なすべてのメタ・データ・キーの参照リストはありません。 :class:`Field` オブジェクトで定義された各キーは異なるコンポーネントで使用でき、それらのコンポーネントのみがそれについて知っています。プロジェクトで他の :class:`Field` キーを定義して使用することもできます。 :class:`Field` オブジェクトの主な目的は、すべてのフィールド・メタ・データを1か所で定義する方法を提供することです。 通常、各フィールドに動作が依存するコンポーネントは、特定のフィールド・キーを使用してその動作を構成します。 各コンポーネントで使用されているメタ・データ・キーを確認するには、ドキュメントを参照する必要があります。"

#: ../../topics/items.rst:73
msgid ""
"It's important to note that the :class:`Field` objects used to declare "
"the item do not stay assigned as class attributes. Instead, they can be "
"accessed through the :attr:`Item.fields` attribute."
msgstr "アイテムの宣言に使用される :class:`Field` オブジェクトは、クラス属性として割り当てられたままにならないことに注意することが重要です。 代わりに、 :attr:`Item.fields` 属性を介してアクセスできます。"

#: ../../topics/items.rst:78
msgid "Working with Items"
msgstr "アイテムで作業する"

#: ../../topics/items.rst:80
msgid ""
"Here are some examples of common tasks performed with items, using the "
"``Product`` item :ref:`declared above  <topics-items-declaring>`. You "
"will notice the API is very similar to the `dict API`_."
msgstr "ここで、 :ref:`先程宣言した<topics-items-declaring>` ``Product`` アイテムを使って、アイテムで実行される一般的なタスクの例をいくつか示します。 APIは辞書API(`dict API`_)に非常に似ていることに気付くでしょう。"

#: ../../topics/items.rst:85
msgid "Creating items"
msgstr "アイテムの作成"

#: ../../topics/items.rst:94
msgid "Getting field values"
msgstr "フィールド値の取得"

#: ../../topics/items.rst:135
msgid "Setting field values"
msgstr "フィールド値のセット"

#: ../../topics/items.rst:149
msgid "Accessing all populated values"
msgstr "読み込まれたすべての値へのアクセス"

#: ../../topics/items.rst:151
msgid "To access all populated values, just use the typical `dict API`_::"
msgstr "読み込まれたすべての値にアクセスするには、典型的な辞書API(`dict API`_)を使用するだけです::"

#: ../../topics/items.rst:163
msgid "Copying items"
msgstr "アイテムのコピー"

#: ../../topics/items.rst:165
msgid ""
"To copy an item, you must first decide whether you want a shallow copy or"
" a deep copy."
msgstr "アイテムをコピーするには、あなたは最初に浅いコピーとディープ・コピーのどちらを使用するかを決定する必要があります。"

#: ../../topics/items.rst:168
msgid ""
"If your item contains mutable_ values like lists or dictionaries, a "
"shallow copy will keep references to the same mutable values across all "
"different copies."
msgstr "アイテムにリストや辞書などのミュータブル(mutable_)値が含まれている場合、浅いコピーは、すべての異なるコピー間で同じミュータブル値への参照を保持します。"

#: ../../topics/items.rst:174
msgid ""
"For example, if you have an item with a list of tags, and you create a "
"shallow copy of that item, both the original item and the copy have the "
"same list of tags. Adding a tag to the list of one of the items will add "
"the tag to the other item as well."
msgstr "たとえば、タグのリストを持つアイテムがあり、そのアイテムの浅いコピーを作成する場合、元のアイテムとコピーの両方に同じタグのリストがあります。 アイテムの1つのリストにタグを追加すると、他のアイテムにもタグが追加されます。"

#: ../../topics/items.rst:179
msgid "If that is not the desired behavior, use a deep copy instead."
msgstr "それが望ましい振る舞いでない場合は、代わりにディープ・コピーを使用します。"

#: ../../topics/items.rst:181
msgid "See the `documentation of the copy module`_ for more information."
msgstr "詳細は `documentation of the copy module`_ 参照。"

#: ../../topics/items.rst:185
msgid ""
"To create a shallow copy of an item, you can either call "
":meth:`~scrapy.item.Item.copy` on an existing item (``product2 = "
"product.copy()``) or instantiate your item class from an existing item "
"(``product2 = Product(product)``)."
msgstr "アイテムの浅いコピーを作成するには、あなたは、既存のアイテムで :meth:`~scrapy.item.Item.copy` を呼び出す(``product2 = product.copy()``)か、あるいは、既存のアイテムからアイテム・クラスをインスタンス化(``product2 = Product(product)``)のいずれかが可能です。"

#: ../../topics/items.rst:190
msgid ""
"To create a deep copy, call :meth:`~scrapy.item.Item.deepcopy` instead "
"(``product2 = product.deepcopy()``)."
msgstr "ディープ・コピーを作成するには、代わりに :meth:`~scrapy.item.Item.deepcopy` を呼び出します(``product2 = product.deepcopy()``)。"

#: ../../topics/items.rst:195
msgid "Other common tasks"
msgstr "その他の一般的な作業"

#: ../../topics/items.rst:197
msgid "Creating dicts from items::"
msgstr "アイテムから辞書を作成する::"

#: ../../topics/items.rst:202
msgid "Creating items from dicts::"
msgstr "辞書からアイテムを作成する::"

#: ../../topics/items.rst:213
msgid "Extending Items"
msgstr "アイテムの拡張"

#: ../../topics/items.rst:215
msgid ""
"You can extend Items (to add more fields or to change some metadata for "
"some fields) by declaring a subclass of your original Item."
msgstr "あなたは、元のアイテムのサブクラスを宣言することにより、アイテムを拡張できます(フィールドを追加したり、フィールドのメタ・データを変更したりできます)。"

#: ../../topics/items.rst:218
msgid "For example::"
msgstr "例えば::"

#: ../../topics/items.rst:224
msgid ""
"You can also extend field metadata by using the previous field metadata "
"and appending more values, or changing existing values, like this::"
msgstr "次のように、あなたは、以前のフィールド・メタ・データを使用して値を追加したり、既存の値を変更したりして、フィールド・メタ・データを拡張することもできます::"

#: ../../topics/items.rst:230
msgid ""
"That adds (or replaces) the ``serializer`` metadata key for the ``name`` "
"field, keeping all the previously existing metadata values."
msgstr "これは、 ``name`` フィールドの ``serializer`` メタ・データ・キーを追加(または置換)し、以前に存在したすべてのメタ・データ値を保持します。"

#: ../../topics/items.rst:234
msgid "Item objects"
msgstr "アイテム・オブジェクト"

#: ../../topics/items.rst:238
msgid "Return a new Item optionally initialized from the given argument."
msgstr "オプションで指定した引数によって初期化された新しいItemを返します。"

#: ../../topics/items.rst:240
msgid ""
"Items replicate the standard `dict API`_, including its constructor. The "
"only additional attribute provided by Items is:"
msgstr "アイテムは、コンストラクタを含む標準の辞書API(`dict API`_)を複製します。 アイテムによって提供される追加の属性は次のとおりです:"

#: ../../topics/items.rst:245
msgid ""
"A dictionary containing *all declared fields* for this Item, not only "
"those populated. The keys are the field names and the values are the "
":class:`Field` objects used in the :ref:`Item declaration <topics-items-"
"declaring>`."
msgstr "読み込まれたフィールドだけでなく、このアイテムの *すべての宣言済みフィールド* を含む辞書。 キーはフィールド名で、値は :ref:`アイテム宣言<topics-items-declaring>` で使用される :class:`Field` オブジェクトです。"

#: ../../topics/items.rst:253
msgid "Field objects"
msgstr "フィールド・オブジェクト"

#: ../../topics/items.rst:257
msgid ""
"The :class:`Field` class is just an alias to the built-in `dict`_ class "
"and doesn't provide any extra functionality or attributes. In other "
"words, :class:`Field` objects are plain-old Python dicts. A separate "
"class is used to support the :ref:`item declaration syntax <topics-items-"
"declaring>` based on class attributes."
msgstr ":class:`Field` クラスは組み込みの `dict`_ クラスの単なるエイリアスであり、追加の機能や属性を提供しません。 言い換えれば、 :class:`Field` オブジェクトは昔ながらのPython辞書です。 別のクラスを使用して、クラス属性に基づいて :ref:`アイテム宣言構文<topics-items-declaring>` をサポートします。"

