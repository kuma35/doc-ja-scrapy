# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2008–2018, Scrapy developers
# This file is distributed under the same license as the Scrapy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Scrapy \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-09-16 22:00+0900\n"
"PO-Revision-Date: 2019-09-23 15:31+0900\n"
"Last-Translator: kuma35\n"
"Language: ja_JP\n"
"Language-Team: Japanese\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../../topics/selectors.rst:5
msgid "Selectors"
msgstr "セレクター"

#: ../../topics/selectors.rst:7
msgid ""
"When you're scraping web pages, the most common task you need to perform "
"is to extract data from the HTML source. There are several libraries "
"available to achieve this, such as:"
msgstr "あなたがWebページをスクレイピングする場合、実行する必要がある最も一般的なタスクは、HTMLソースからデータを抽出することです。 これを実現するために利用可能ないくつかのライブラリがあります。:"

#: ../../topics/selectors.rst:11
msgid ""
"`BeautifulSoup`_ is a very popular web scraping library among Python "
"programmers which constructs a Python object based on the structure of "
"the HTML code and also deals with bad markup reasonably well, but it has "
"one drawback: it's slow."
msgstr "`BeautifulSoup`_ は、Pythonプログラマーの間で非常に人気のあるWebスクレイピングライブラリであり、HTMLコードの構造に基づいてPythonオブジェクトを構築し、悪いマークアップも合理的に処理しますが、1つの欠点があります。遅いんです。"

#: ../../topics/selectors.rst:16
msgid ""
"`lxml`_ is an XML parsing library (which also parses HTML) with a "
"pythonic API based on `ElementTree`_. (lxml is not part of the Python "
"standard library.)"
msgstr "`lxml`_ は、 `ElementTree`_ に基づいたPython APIを備えたXMLパースライブラリ(HTMLもパースします)です。(lxmlはPython標準ライブラリの一部ではありません。)"

#: ../../topics/selectors.rst:20
msgid ""
"Scrapy comes with its own mechanism for extracting data. They're called "
"selectors because they \"select\" certain parts of the HTML document "
"specified either by `XPath`_ or `CSS`_ expressions."
msgstr "Scrapyには、データを抽出するための独自のメカニズムが備わっています。 これらは、 `XPath`_ または `CSS`_ 式で指定されたHTMLドキュメントの特定の部分を「選択(select)」するため、セレクター(selector)と呼ばれます。"

#: ../../topics/selectors.rst:24
msgid ""
"`XPath`_ is a language for selecting nodes in XML documents, which can "
"also be used with HTML. `CSS`_ is a language for applying styles to HTML "
"documents. It defines selectors to associate those styles with specific "
"HTML elements."
msgstr "`XPath`_ は、XMLドキュメントでノードを選択するための言語であり、HTMLでも使用できます。 `CSS`_ は、HTMLドキュメントにスタイルを適用するための言語です。 これらのスタイルを特定のHTML要素に関連付けるセレクターを定義します。"

#: ../../topics/selectors.rst:29
msgid ""
"Scrapy Selectors is a thin wrapper around `parsel`_ library; the purpose "
"of this wrapper is to provide better integration with Scrapy Response "
"objects."
msgstr "Scrapyセレクターは、 `parsel`_ ライブラリの薄いラッパーです。 このラッパーの目的は、Scrapy Responseオブジェクトとの統合を改善することです。"

#: ../../topics/selectors.rst:32
msgid ""
"`parsel`_ is a stand-alone web scraping library which can be used without"
" Scrapy. It uses `lxml`_ library under the hood, and implements an easy "
"API on top of lxml API. It means Scrapy selectors are very similar in "
"speed and parsing accuracy to lxml."
msgstr "`parsel`_ は、Scrapyなしで使用できるスタンドアロンのWebスクレイピングライブラリです。 内部で `lxml`_ ライブラリを使用し、lxml APIの上に簡単なAPIを実装します。 これは、Scrapyセレクターの速度と解析精度が、lxmlに非常に似ていることを意味します。"

#: ../../topics/selectors.rst:46 ../../topics/selectors.rst:97
msgid "Using selectors"
msgstr "セレクターの使用"

#: ../../topics/selectors.rst:49
msgid "Constructing selectors"
msgstr "セレクターの構築"

#: ../../topics/selectors.rst:53
msgid ""
"Response objects expose a :class:`~scrapy.selector.Selector` instance on "
"``.selector`` attribute::"
msgstr "Responseオブジェクトは ``.selector`` 属性で :class:`~scrapy.selector.Selector` インスタンスを公開します。::"

#: ../../topics/selectors.rst:59
msgid ""
"Querying responses using XPath and CSS is so common that responses "
"include two more shortcuts: ``response.xpath()`` and ``response.css()``::"
msgstr "XPathとCSSを使用したレスポンスのクエリは非常によく使われるので、レスポンスにはさらに2つのショートカットが含まれます。 ``response.xpath()`` と ``response.css()`` です。::"

#: ../../topics/selectors.rst:67
msgid ""
"Scrapy selectors are instances of :class:`~scrapy.selector.Selector` "
"class constructed by passing either :class:`~scrapy.http.TextResponse` "
"object or markup as an unicode string (in ``text`` argument). Usually "
"there is no need to construct Scrapy selectors manually: ``response`` "
"object is available in Spider callbacks, so in most cases it is more "
"convenient to use ``response.css()`` and ``response.xpath()`` shortcuts. "
"By using ``response.selector`` or one of these shortcuts you can also "
"ensure the response body is parsed only once."
msgstr "Scrapyセレクターは、 :class:`~scrapy.http.TextResponse` オブジェクトまたはUnicode文字列でマークアップを渡す(``text`` 引数で)ことで構築された :class:`~scrapy.selector.Selector` クラスのインスタンスです。通常、Scrapyセレクターを手動で作成する必要はありません。 ``response`` オブジェクトはSpiderコールバックで使用できるため、ほとんどの場合、 ``response.css()`` ショートカットと ``response.xpath()`` ショートカットを使用する方が便利です。  ``response.selector`` またはこれらのショートカットのいずれかを使用することで、レスポンス・ボディが1回だけパースされることを確認することもできます。"

#: ../../topics/selectors.rst:76
msgid ""
"But if required, it is possible to use ``Selector`` directly. "
"Constructing from text::"
msgstr "ただし、必要に応じて、セレクターを直接使用することができます。 テキストから構築する場合は以下です。::"

#: ../../topics/selectors.rst:84
msgid ""
"Constructing from response - :class:`~scrapy.http.HtmlResponse` is one of"
" :class:`~scrapy.http.TextResponse` subclasses::"
msgstr "レスポンスから構築する場合、 :class:`~scrapy.http.HtmlResponse` は :class:`~scrapy.http.TextResponse` サブクラスの1つです。::"

#: ../../topics/selectors.rst:93
msgid ""
"``Selector`` automatically chooses the best parsing rules (XML vs HTML) "
"based on input type."
msgstr "セレクターは、入力タイプに基づいて最適なパース・ルール(XMLかHTML)を自動的に選択します。"

#: ../../topics/selectors.rst:99
msgid ""
"To explain how to use the selectors we'll use the ``Scrapy shell`` (which"
" provides interactive testing) and an example page located in the Scrapy "
"documentation server:"
msgstr "セレクターの使用方法を説明するために、私たちは、「Scrapyシェル」(対話的なテストを提供します)とScrapyドキュメントサーバーにあるサンプルページを使用します。:"

#: ../../topics/selectors.rst:103
msgid "https://docs.scrapy.org/en/latest/_static/selectors-sample1.html"
msgstr "https://docs.scrapy.org/en/latest/_static/selectors-sample1.html"

#: ../../topics/selectors.rst:107
msgid "For the sake of completeness, here's its full HTML code:"
msgstr "完全を期すために、完全なHTMLコードを次に示します。:"

#: ../../topics/selectors.rst:114
msgid "First, let's open the shell::"
msgstr "まず、シェルを開きましょう。::"

#: ../../topics/selectors.rst:118
msgid ""
"Then, after the shell loads, you'll have the response available as "
"``response`` shell variable, and its attached selector in "
"``response.selector`` attribute."
msgstr "次に、シェルがロードされると、レスポンスが ``response`` シェル変数として使用可能になり、 ``response.selector`` 属性にそのセレクターが当てはめられます。"

#: ../../topics/selectors.rst:121
msgid ""
"Since we're dealing with HTML, the selector will automatically use an "
"HTML parser."
msgstr "HTMLを扱っているため、セレクターは自動的にHTMLパーサーを使用します。"

#: ../../topics/selectors.rst:125
msgid ""
"So, by looking at the :ref:`HTML code <topics-selectors-htmlcode>` of "
"that page, let's construct an XPath for selecting the text inside the "
"title tag::"
msgstr "それでは、そのページの :ref:`HTMLコード<topics-selectors-htmlcode>` を見て、タイトルタグ内のテキストを選択するためのXPathを作成しましょう。::"

#: ../../topics/selectors.rst:131
msgid ""
"To actually extract the textual data, you must call the selector "
"``.get()`` or ``.getall()`` methods, as follows::"
msgstr "テキストデータを実際に抽出するには、次のようにセレクタ ``.get()`` または ``.getall()`` メソッドを呼び出す必要があります。::"

#: ../../topics/selectors.rst:139
msgid ""
"``.get()`` always returns a single result; if there are several matches, "
"content of a first match is returned; if there are no matches, None is "
"returned. ``.getall()`` returns a list with all results."
msgstr "``.get()`` は常に単一の結果を返します。 複数の一致がある場合、最初の一致のコンテンツが返されます。 一致するものがない場合はNoneが返されます。 ``.getall()`` はすべての結果を含むリストを返します。"

#: ../../topics/selectors.rst:143
msgid ""
"Notice that CSS selectors can select text or attribute nodes using CSS3 "
"pseudo-elements::"
msgstr "CSSセレクターは、CSS3疑似要素を使用してテキストまたは属性ノードを選択できることに注意してください。::"

#: ../../topics/selectors.rst:149
msgid ""
"As you can see, ``.xpath()`` and ``.css()`` methods return a "
":class:`~scrapy.selector.SelectorList` instance, which is a list of new "
"selectors. This API can be used for quickly selecting nested data::"
msgstr "あなたがご覧のとおり、 ``.xpath()`` と ``.css()`` メソッドは :class:`~scrapy.selector.SelectorList` のインスタンスを返します。これは新しいセレクターのリストです。 このAPIは、ネストされたデータをすばやく選択するために使用できます。::"

#: ../../topics/selectors.rst:160
msgid ""
"If you want to extract only the first matched element, you can call the "
"selector ``.get()`` (or its alias ``.extract_first()`` commonly used in "
"previous Scrapy versions)::"
msgstr "あなたが最初に一致した要素のみを抽出したい場合は、セレクタ ``.get()`` (または以前のScrapyバージョンで一般的に使用されていたエイリアス ``.extract_first()`` )を呼び出すことができます。::"

#: ../../topics/selectors.rst:167
msgid "It returns ``None`` if no element was found::"
msgstr "要素が見つからなかった場合は ``None`` を返します。::"

#: ../../topics/selectors.rst:172
msgid ""
"A default return value can be provided as an argument, to be used instead"
" of ``None``:"
msgstr "``None`` の代わりに使用されるデフォルトの戻り値を引数として提供できます。:"

#: ../../topics/selectors.rst:178
msgid ""
"Instead of using e.g. ``'@src'`` XPath it is possible to query for "
"attributes using ``.attrib`` property of a "
":class:`~scrapy.selector.Selector`::"
msgstr "例えば ``'@src'`` のようなXPathを使用する代わりに、 :class:`~scrapy.selector.Selector` の ``.attrib`` プロパティを使用して属性を問い合わせることができます。::"

#: ../../topics/selectors.rst:188
msgid ""
"As a shortcut, ``.attrib`` is also available on SelectorList directly; it"
" returns attributes for the first matching element::"
msgstr "ショートカットとして、 ``.attrib`` はSelectorListでも直接利用できます。 最初に一致する要素の属性を返します。::"

#: ../../topics/selectors.rst:194
msgid ""
"This is most useful when only a single result is expected, e.g. when "
"selecting by id, or selecting unique elements on a web page::"
msgstr "これは、単一の結果のみが予想される場合に最も役立ちます。例えばIDで選択する場合、またはWebページ上の一意の要素を選択する場合。::"

#: ../../topics/selectors.rst:200
msgid "Now we're going to get the base URL and some image links::"
msgstr "今や、私たちは、ベースURLといくつかの画像リンクを取得します。::"

#: ../../topics/selectors.rst:242
msgid "Extensions to CSS Selectors"
msgstr "CSSセレクターの拡張機能"

#: ../../topics/selectors.rst:244
msgid ""
"Per W3C standards, `CSS selectors`_ do not support selecting text nodes "
"or attribute values. But selecting these is so essential in a web "
"scraping context that Scrapy (parsel) implements a couple of **non-"
"standard pseudo-elements**:"
msgstr "W3C標準では、 `CSS selectors`_ はテキストノードまたは属性値の選択をサポートしていません。 しかし、これらを選択することは、Webスクレイピングコンテキストでは非常に重要であるため、Scrapy(parsel)はいくつかの **非標準の擬似要素** を実装しています。:"

#: ../../topics/selectors.rst:249
msgid "to select text nodes, use ``::text``"
msgstr "テキストノードを選択するには ``::text`` を使用します"

#: ../../topics/selectors.rst:250
msgid ""
"to select attribute values, use ``::attr(name)`` where *name* is the name"
" of the attribute that you want the value of"
msgstr "属性値を選択するには ``::attr(name)`` を使用します。 *name* は、あなたが値を取得したい属性の名前です"

#: ../../topics/selectors.rst:254
msgid ""
"These pseudo-elements are Scrapy-/Parsel-specific. They will most "
"probably not work with other libraries like `lxml`_ or `PyQuery`_."
msgstr "これらの擬似要素はScrapy/Parsel固有です。 ほとんどの場合、 `lxml`_ や `PyQuery`_ などの他のライブラリでは動作しません。"

#: ../../topics/selectors.rst:260
msgid "Examples:"
msgstr "例:"

#: ../../topics/selectors.rst:262
msgid ""
"``title::text`` selects children text nodes of a descendant ``<title>`` "
"element::"
msgstr "``title::text`` は ``<title>`` の子孫のテキストノードを選択します。::"

#: ../../topics/selectors.rst:267
msgid ""
"``*::text`` selects all descendant text nodes of the current selector "
"context::"
msgstr "``*::text`` は、現在のセレクターコンテキストの全ての子孫テキストノードを選択します。::"

#: ../../topics/selectors.rst:282
msgid ""
"``foo::text`` returns no results if ``foo`` element exists, but contains "
"no text (i.e. text is empty)::"
msgstr "``foo::text`` は、 ``foo`` 要素が存在するが、テキストを含まない場合(つまり、テキストが空の場合)の場合、結果を返しません。"

#: ../../topics/selectors.rst:288
msgid ""
"This means ``.css('foo::text').get()`` could return None even if an "
"element exists. Use ``default=''`` if you always want a string::"
msgstr "つまり、 ``.css('foo::text').get()`` は、要素が存在する場合でもNoneを返す可能性があることを意味します。 常に文字列が必要な場合は ``default=''`` 引数を使用してください。::"

#: ../../topics/selectors.rst:295
msgid "``a::attr(href)`` selects the *href* attribute value of descendant links::"
msgstr "``a::attr(href)`` は、リンクにぶら下がってる *href* 属性値を選択します。::"

#: ../../topics/selectors.rst:305 ../../topics/selectors.rst:933
#: ../../topics/selectors.rst:973
msgid "See also: :ref:`selecting-attributes`."
msgstr ":ref:`selecting-attributes` も参照下さい。"

#: ../../topics/selectors.rst:308
msgid ""
"You cannot chain these pseudo-elements. But in practice it would not make"
" much sense: text nodes do not have attributes, and attribute values are "
"string values already and do not have children nodes."
msgstr "あなたは、これらの擬似要素をチェインさせることはできません。 ただし、実際にはあまり意味がありません。テキストノードには属性がなく、属性値は既に文字列値であり、子ノードはありません。"

#: ../../topics/selectors.rst:317
msgid "Nesting selectors"
msgstr "セレクターを入れ子にする"

#: ../../topics/selectors.rst:319
msgid ""
"The selection methods (``.xpath()`` or ``.css()``) return a list of "
"selectors of the same type, so you can call the selection methods for "
"those selectors too. Here's an example::"
msgstr "選択メソッド(``.xpath()`` または ``.css()``)は同じタイプのセレクターのリストを返すため、これらのセレクターの選択メソッドも呼び出すことができます。 以下に例を示します。::"

#: ../../topics/selectors.rst:344
msgid "Selecting element attributes"
msgstr "要素属性の選択"

#: ../../topics/selectors.rst:346
msgid ""
"There are several ways to get a value of an attribute. First, one can use"
" XPath syntax::"
msgstr "属性の値を取得する方法はいくつかあります。 まず、XPath構文を使用できます。::"

#: ../../topics/selectors.rst:352
msgid ""
"XPath syntax has a few advantages: it is a standard XPath feature, and "
"``@attributes`` can be used in other parts of an XPath expression - e.g. "
"it is possible to filter by attribute value."
msgstr "XPath構文にはいくつかの利点があります。これは標準のXPath機能であり、 ``@attributes`` はXPath式の他の部分で使用できます。 属性値でフィルタリングすることが可能です。"

#: ../../topics/selectors.rst:356
msgid ""
"Scrapy also provides an extension to CSS selectors (``::attr(...)``) "
"which allows to get attribute values::"
msgstr "Scrapyは、属性値を取得できるCSSセレクター(``::attr(...)``)の拡張機能も提供します。::"

#: ../../topics/selectors.rst:362
msgid ""
"In addition to that, there is a ``.attrib`` property of Selector. You can"
" use it if you prefer to lookup attributes in Python code, without using "
"XPaths or CSS extensions::"
msgstr "それに加えて、Selectorの ``.attrib`` プロパティがあります。 XPathまたはCSS拡張機能を使用せずに、Pythonコードで属性を検索する場合に使用できます。::"

#: ../../topics/selectors.rst:369
msgid ""
"This property is also available on SelectorList; it returns a dictionary "
"with attributes of a first matching element. It is convenient to use when"
" a selector is expected to give a single result (e.g. when selecting by "
"element ID, or when selecting an unique element on a page)::"
msgstr "このプロパティはSelectorListでも使用できます。 最初に一致した要素の属性を持つ辞書を返します。 セレクターが単一の結果を返すと予想される場合(たとえば、要素IDで選択する場合、またはページ上の一意の要素を選択する場合)に使用すると便利です。::"

#: ../../topics/selectors.rst:379
msgid "``.attrib`` property of an empty SelectorList is empty::"
msgstr "空のSelectorListの ``.attrib`` プロパティは空です。::"

#: ../../topics/selectors.rst:385
msgid "Using selectors with regular expressions"
msgstr "セレクターで正規表現を使う"

#: ../../topics/selectors.rst:387
msgid ""
":class:`~scrapy.selector.Selector` also has a ``.re()`` method for "
"extracting data using regular expressions. However, unlike using "
"``.xpath()`` or ``.css()`` methods, ``.re()`` returns a list of unicode "
"strings. So you can't construct nested ``.re()`` calls."
msgstr ":class:`~scrapy.selector.Selector` には、正規表現を使用してデータを抽出する ``.re()`` メソッドもあります。 ただし、 ``.xpath()`` または ``.css()`` メソッドを使用するのとは異なり、 ``.re()`` はUnicode文字列のリストを返します。 したがって、ネストした ``.re()`` 呼び出しを構築することはできません。"

#: ../../topics/selectors.rst:392
msgid ""
"Here's an example used to extract image names from the :ref:`HTML code "
"<topics-selectors-htmlcode>` above::"
msgstr "上記の :ref:`HTMLコード<topics-selectors-htmlcode>` から画像名を抽出する例を次に示します。::"

#: ../../topics/selectors.rst:402
msgid ""
"There's an additional helper reciprocating ``.get()`` (and its alias "
"``.extract_first()``) for ``.re()``, named ``.re_first()``. Use it to "
"extract just the first matching string::"
msgstr "``.re()`` のために ``.get()`` (およびそのエイリアス ``.extract_first()``)に対応する追加のヘルパーがあり、名前は ``.re_first()`` です。 これを使用して、最初に一致する文字列のみを抽出します。::"

#: ../../topics/selectors.rst:412
msgid "extract() and extract_first()"
msgstr "extract() と extract_first()"

#: ../../topics/selectors.rst:414
msgid ""
"If you're a long-time Scrapy user, you're probably familiar with "
"``.extract()`` and ``.extract_first()`` selector methods. Many blog posts"
" and tutorials are using them as well. These methods are still supported "
"by Scrapy, there are **no plans** to deprecate them."
msgstr "あなたが長年のScrapyユーザーなら、おそらく  ``.extract()`` と ``.extract_first()`` セレクターメソッドに慣れているでしょう。 多くのブログ投稿とチュートリアルも同様にそれらを使用しています。 これらのメソッドはまだScrapyでサポートされており、それらを **非推奨にする計画はありません** 。"

#: ../../topics/selectors.rst:419
msgid ""
"However, Scrapy usage docs are now written using ``.get()`` and "
"``.getall()`` methods. We feel that these new methods result in a more "
"concise and readable code."
msgstr "けれども、Scrapyの使用法の文書は  ``.get()`` と ``.getall()`` メソッドを使用して記述されるようになりました。 私たちは、これらの新しいメソッドは、より簡潔で読みやすいコードになると思います。"

#: ../../topics/selectors.rst:423
msgid "The following examples show how these methods map to each other."
msgstr "次の例は、これらのメソッドが互いにどのようにマッピングされるかを示しています。"

#: ../../topics/selectors.rst:425
msgid "``SelectorList.get()`` is the same as ``SelectorList.extract_first()``::"
msgstr "``SelectorList.get()`` は ``SelectorList.extract_first()`` と同じです::"

#: ../../topics/selectors.rst:432
msgid "``SelectorList.getall()`` is the same as ``SelectorList.extract()``::"
msgstr "``SelectorList.getall()`` は ``SelectorList.extract()`` と同じです::"

#: ../../topics/selectors.rst:439
msgid "``Selector.get()`` is the same as ``Selector.extract()``::"
msgstr "``Selector.get()`` は ``Selector.extract()`` と同じです::"

#: ../../topics/selectors.rst:446
msgid ""
"For consistency, there is also ``Selector.getall()``, which returns a "
"list::"
msgstr "一貫性のために、リストを返す ``Selector.getall()`` もあります::"

#: ../../topics/selectors.rst:451
msgid ""
"So, the main difference is that output of ``.get()`` and ``.getall()`` "
"methods is more predictable: ``.get()`` always returns a single result, "
"``.getall()`` always returns a list of all extracted results. With "
"``.extract()`` method it was not always obvious if a result is a list or "
"not; to get a single result either ``.extract()`` or ``.extract_first()``"
" should be called."
msgstr "したがって、主な違いは、``.get()`` と ``.getall()`` メソッドの出力はより予測可能なことです。 ``.get()``は常に単一の結果、 ``.getall()`` は常に抽出されたすべての結果のリストを返します。 ``.extract()`` メソッドでは、結果がリストであるかどうかは必ずしも明らかではありませんでした。 単一の結果を得るには、 ``.extract()`` または ``.extract_first()`` を呼び出す必要があります。"

#: ../../topics/selectors.rst:461
msgid "Working with XPaths"
msgstr "XPathsで作業する"

# .. _`XPath tutorial`: http://www.zvon.org/comp/r/tut-XPath_1.html
# を読んでみたが短い解説をGoogle翻訳に掛ける程度で充分読み下せる。
#: ../../topics/selectors.rst:463
msgid ""
"Here are some tips which may help you to use XPath with Scrapy selectors "
"effectively. If you are not much familiar with XPath yet, you may want to"
" take a look first at this `XPath tutorial`_."
msgstr "ScrapyセレクターでXPathを効果的に使用するのに役立つヒントをいくつか紹介します。 XPathにまだ慣れていない場合は、まず、 `XPath tutorial`_ をご覧ください。"

#: ../../topics/selectors.rst:468
msgid "Some of the tips are based on `this post from ScrapingHub's blog`_."
msgstr "いくつかのヒントは `this post from ScrapingHub's blog`_ に基づいています。"

#: ../../topics/selectors.rst:477
msgid "Working with relative XPaths"
msgstr "相対XPathで作業する"

#: ../../topics/selectors.rst:479
msgid ""
"Keep in mind that if you are nesting selectors and use an XPath that "
"starts with ``/``, that XPath will be absolute to the document and not "
"relative to the ``Selector`` you're calling it from."
msgstr "セレクターをネストし、``/`` で始まるXPathを使用する場合、そのXPathはドキュメントの絶対パスであり、呼び出し元のセレクターに対して相対的ではないことに注意してください。"

#: ../../topics/selectors.rst:483
msgid ""
"For example, suppose you want to extract all ``<p>`` elements inside "
"``<div>`` elements. First, you would get all ``<div>`` elements::"
msgstr "たとえば、 ``<div>`` 要素内のすべての ``<p>`` 要素を抽出するとします。最初に、すべての ``<div>`` 要素を取得します::"

#: ../../topics/selectors.rst:488
msgid ""
"At first, you may be tempted to use the following approach, which is "
"wrong, as it actually extracts all ``<p>`` elements from the document, "
"not only those inside ``<div>`` elements::"
msgstr "最初は、以下のアプローチを使用したくなるかもしれませんが、実際には ``<div>`` 要素内の要素だけでなく、ドキュメント内すべての ``<p>`` 要素を抽出するため、間違っています::"

# 文脈からして原文がミスってるぽい。勝手に修正。 ``.//p`` → ``.``
#: ../../topics/selectors.rst:495
msgid ""
"This is the proper way to do it (note the dot prefixing the ``.//p`` "
"XPath)::"
msgstr "以下が適切な方法です(XPathの先頭に ``.`` が付いていることに注意してください)::"

#: ../../topics/selectors.rst:500
msgid "Another common case would be to extract all direct ``<p>`` children::"
msgstr "もう一つの一般的なやり方は、すべての子 ``<p>`` を直接抽出することです::"

#: ../../topics/selectors.rst:505
msgid ""
"For more details about relative XPaths see the `Location Paths`_ section "
"in the XPath specification."
msgstr "相対XPathの詳細については、XPath仕様の `Location Paths`_ 節を参照してください。"

#: ../../topics/selectors.rst:511
msgid "When querying by class, consider using CSS"
msgstr "クラスによってクエリーする場合、CSSの使用を検討してください"

#: ../../topics/selectors.rst:513
msgid ""
"Because an element can contain multiple CSS classes, the XPath way to "
"select elements by class is the rather verbose::"
msgstr "要素には複数のCSSクラスを含めることができるため、クラスごとに要素を選択するXPathの方法はかなり冗長です::"

#: ../../topics/selectors.rst:518
msgid ""
"If you use ``@class='someclass'`` you may end up missing elements that "
"have other classes, and if you just use ``contains(@class, 'someclass')``"
" to make up for that you may end up with more elements that you want, if "
"they have a different class name that shares the string ``someclass``."
msgstr "あなたが ``@class='someclass'`` を使用すると、他のクラスを持つ要素が欠落する可能性があります。それを補うために、単に ``contains(@class, 'someclass')`` を使用すると、文字列 ``someclass`` を共有する別のクラス名がある場合、より多くの要素が必要になる可能性があります。"

#: ../../topics/selectors.rst:523
msgid ""
"As it turns out, Scrapy selectors allow you to chain selectors, so most "
"of the time you can just select by class using CSS and then switch to "
"XPath when needed::"
msgstr "この場合、Scrapyセレクターを使用するとセレクターをチェインできるため、ほとんどの場合、CSSを使用してクラスごとに選択し、それから必要に応じてXPathに切り替えることができます。::"

#: ../../topics/selectors.rst:531
msgid ""
"This is cleaner than using the verbose XPath trick shown above. Just "
"remember to use the ``.`` in the XPath expressions that will follow."
msgstr "これは、上記の詳細なXPathトリックを使用するよりもクリーンです。 後に続くXPath式で ``.`` を使用することを忘れないでください。"

#: ../../topics/selectors.rst:535
msgid "Beware of the difference between //node[1] and (//node)[1]"
msgstr "//node[1] と (//node)[1] の違いに注意してください"

#: ../../topics/selectors.rst:537
msgid ""
"``//node[1]`` selects all the nodes occurring first under their "
"respective parents."
msgstr "``//node[1]`` は、それぞれの親(parents)の下で最初に発生するすべてのノードを選択します。"

#: ../../topics/selectors.rst:539
msgid ""
"``(//node)[1]`` selects all the nodes in the document, and then gets only"
" the first of them."
msgstr "``(//node)[1]`` ドキュメント内のすべてのノードを選択し、その最初のノードのみを取得します。"

#: ../../topics/selectors.rst:541 ../../topics/selectors.rst:587
msgid "Example::"
msgstr "例::"

#: ../../topics/selectors.rst:557
msgid "This gets all first ``<li>``  elements under whatever it is its parent::"
msgstr "これは、``<li>`` 要素の親(parent)である全ての要素の子としてある、``<li>`` 要素達の最初のを取得します::"

#: ../../topics/selectors.rst:562
msgid "And this gets the first ``<li>``  element in the whole document::"
msgstr "ドキュメント全体の ``<li>`` 要素の最初のものを返します。::"

#: ../../topics/selectors.rst:567
msgid "This gets all first ``<li>``  elements under an ``<ul>``  parent::"
msgstr "これは `` <ul> `` の子に `` <li> `` があるパターン全てが対象となり、それぞれでの最初の``<li>`` 要素を取得します。::"

#: ../../topics/selectors.rst:572
msgid ""
"And this gets the first ``<li>``  element under an ``<ul>``  parent in "
"the whole document::"
msgstr "ドキュメント全体の、 ``<ul>`` の子に ``<li>`` があるパターン全てが対象となり、その中で、一番最初の ``<li>`` 要素を取得します::"

#: ../../topics/selectors.rst:578
msgid "Using text nodes in a condition"
msgstr "条件によるテキストノードの使用"

#: ../../topics/selectors.rst:580
msgid ""
"When you need to use the text content as argument to an `XPath string "
"function`_, avoid using ``.//text()`` and use just ``.`` instead."
msgstr "あなたがテキスト内容をXPath文字列関数(`XPath string function`_)の引数として使用する必要がある場合、 ``.//text()`` の使用を避け、代わりに ``.`` のみを使用してください。"

#: ../../topics/selectors.rst:583
msgid ""
"This is because the expression ``.//text()`` yields a collection of text "
"elements -- a *node-set*. And when a node-set is converted to a string, "
"which happens when it is passed as argument to a string function like "
"``contains()`` or ``starts-with()``, it results in the text for the first"
" element only."
msgstr "これは、``.//text()`` 式が *ノードセット* -- テキスト要素のコレクション -- を生成するためです。 そして、ノードセットが文字列に変換されるとき、つまり、 ``contains()`` または ``starts-with()`` のような文字列関数への引数として渡されるとき、最初の要素のテキストのみが渡されます。"

#: ../../topics/selectors.rst:592
msgid "Converting a *node-set* to string::"
msgstr "*ノードセット* から文字列への変換::"

#: ../../topics/selectors.rst:599
msgid ""
"A *node* converted to a string, however, puts together the text of itself"
" plus of all its descendants::"
msgstr "ただし、文字列に変換された *ノード* は、それ自体のテキストとそのすべての子孫のテキストを一緒にします。"

#: ../../topics/selectors.rst:606
msgid "So, using the ``.//text()`` node-set won't select anything in this case::"
msgstr "したがって、 ``.//text()`` ノードセットを使用しても、この場合は何も選択されません::"

#: ../../topics/selectors.rst:611
msgid "But using the ``.`` to mean the node, works::"
msgstr "しかし、ノードを意味するために ``.`` を使用すると、動作します::"

#: ../../topics/selectors.rst:621
msgid "Variables in XPath expressions"
msgstr "XPath式の変数"

#: ../../topics/selectors.rst:623
msgid ""
"XPath allows you to reference variables in your XPath expressions, using "
"the ``$somevariable`` syntax. This is somewhat similar to parameterized "
"queries or prepared statements in the SQL world where you replace some "
"arguments in your queries with placeholders like ``?``, which are then "
"substituted with values passed with the query."
msgstr "XPathでは、 ``$somevariable`` 構文を使用して、XPath式の変数を参照できます。 これは、SQLの世界での、クエリの引数を ``?`` のようなプレースホルダーに置き換え、クエリで渡された値で置換されるパラメータークエリまたはプリペアードステートメントに似ているところがあります。"

#: ../../topics/selectors.rst:629
msgid ""
"Here's an example to match an element based on its \"id\" attribute "
"value, without hard-coding it (that was shown previously)::"
msgstr "\"id\" 属性値に基づいて、ハードコーディングせずに要素をマッチする例を次に示します(ハードコーディングする例は前述しました)::"

#: ../../topics/selectors.rst:636
msgid ""
"Here's another example, to find the \"id\" attribute of a ``<div>`` tag "
"containing five ``<a>`` children (here we pass the value ``5`` as an "
"integer)::"
msgstr "別の例として、5つの子 ``<a>`` を含む ``<div>`` タグの \"id\" 属性を見つけます(ここでは整数として値 ``5`` を渡します)::"

#: ../../topics/selectors.rst:642
msgid ""
"All variable references must have a binding value when calling "
"``.xpath()`` (otherwise you'll get a ``ValueError: XPath error:`` "
"exception). This is done by passing as many named arguments as necessary."
msgstr " ``.xpath()`` を呼び出すときは、すべての変数参照にバインディング値が必要です(そうでない場合は ``ValueError: XPath error:`` 例外が発生します)。これは、必要な数の名前付き引数を渡すことで実行されます。"

#: ../../topics/selectors.rst:646
msgid ""
"`parsel`_, the library powering Scrapy selectors, has more details and "
"examples on `XPath variables`_."
msgstr "Scapyセレクターを駆動するライブラリである `parsel`_ には、XPath変数(`XPath variables`_)の詳細と例があります。"

#: ../../topics/selectors.rst:655
msgid "Removing namespaces"
msgstr "名前空間(namespace)の削除"

#: ../../topics/selectors.rst:657
msgid ""
"When dealing with scraping projects, it is often quite convenient to get "
"rid of namespaces altogether and just work with element names, to write "
"more simple/convenient XPaths. You can use the "
":meth:`Selector.remove_namespaces` method for that."
msgstr "スクレイピングプロジェクトを処理する場合、名前空間を完全に削除し、要素名を操作して、より単純で便利なXPathを作成すると非常に便利です。それには :meth:`Selector.remove_namespaces` メソッドを使用できます。"

#: ../../topics/selectors.rst:662
msgid ""
"Let's show an example that illustrates this with the Python Insider blog "
"atom feed."
msgstr "Python Insider blog atom フィードでこれを説明する例を示しましょう。"

#: ../../topics/selectors.rst:666
msgid "First, we open the shell with the url we want to scrape::"
msgstr "まず、あなたがスクレイプしたいURLでシェルを開きます::"

#: ../../topics/selectors.rst:670
msgid "This is how the file starts::"
msgstr "これがファイルの開始方法です::"

#: ../../topics/selectors.rst:683
msgid ""
"You can see several namespace declarations including a default "
"\"http://www.w3.org/2005/Atom\" and another one using the \"gd:\" prefix "
"for \"http://schemas.google.com/g/2005\"."
msgstr "デフォルトの http://www.w3.org/2005/Atom と、 http://schemas.google.com/g/2005 の gd: プレフィックスを使用する別の宣言を含む、いくつかの名前空間宣言を確認できます。"

#: ../../topics/selectors.rst:689
msgid ""
"Once in the shell we can try selecting all ``<link>`` objects and see "
"that it doesn't work (because the Atom XML namespace is obfuscating those"
" nodes)::"
msgstr "シェルに入ったら、すべての ``<link>`` オブジェクトを選択して、機能しないことを確認できます(Atom XML名前空間がこれらのノードを難読化しているため)::"

#: ../../topics/selectors.rst:695
msgid ""
"But once we call the :meth:`Selector.remove_namespaces` method, all nodes"
" can be accessed directly by their names::"
msgstr "しかし、一度、 :meth:`Selector.remove_namespaces` メソッドを呼び出すと、すべてのノードに名前で直接アクセスできます::"

#: ../../topics/selectors.rst:704
msgid ""
"If you wonder why the namespace removal procedure isn't always called by "
"default instead of having to call it manually, this is because of two "
"reasons, which, in order of relevance, are:"
msgstr "あなたは、名前空間削除手順が手動になっていて、デフォルトで常に呼び出されるとは限らないのを疑問に思うかもしれません。これは2つの理由によるものです:"

#: ../../topics/selectors.rst:708
msgid ""
"Removing namespaces requires to iterate and modify all nodes in the "
"document, which is a reasonably expensive operation to perform by default"
" for all documents crawled by Scrapy"
msgstr "名前空間を削除するには、ドキュメント内のすべてのノードを反復して変更する必要があります。これは、Scrapyによってクロールされたすべてのドキュメントに対してデフォルトで実行するのにかなりコストのかかる操作です"

#: ../../topics/selectors.rst:712
msgid ""
"There could be some cases where using namespaces is actually required, in"
" case some element names clash between namespaces. These cases are very "
"rare though."
msgstr "いくつかの要素名が名前空間間で衝突する場合、実際には名前空間を使用する必要がある場合があります。 ただし、これらのケースは非常にまれです。"

#: ../../topics/selectors.rst:718
msgid "Using EXSLT extensions"
msgstr "EXSLT拡張機能の使用"

#: ../../topics/selectors.rst:720
msgid ""
"Being built atop `lxml`_, Scrapy selectors support some `EXSLT`_ "
"extensions and come with these pre-registered namespaces to use in XPath "
"expressions:"
msgstr "`lxml`_ の上に構築されるScrapyセレクターは、いくつかの `EXSLT`_ 拡張をサポートし、XPath式で使用できる、事前登録されたこれらの名前空間が付属します:"

#: ../../topics/selectors.rst:725
msgid "prefix"
msgstr "プレフィックス"

#: ../../topics/selectors.rst:725
msgid "namespace"
msgstr "名前空間"

#: ../../topics/selectors.rst:725
msgid "usage"
msgstr "使い方"

#: ../../topics/selectors.rst:727
msgid "re"
msgstr "re"

#: ../../topics/selectors.rst:727
msgid "\\http://exslt.org/regular-expressions"
msgstr "\\http://exslt.org/regular-expressions"

#: ../../topics/selectors.rst:727
msgid "`regular expressions`_"
msgstr "`regular expressions`_ 参照"

#: ../../topics/selectors.rst:728
msgid "set"
msgstr "set"

#: ../../topics/selectors.rst:728
msgid "\\http://exslt.org/sets"
msgstr "\\http://exslt.org/sets"

#: ../../topics/selectors.rst:728
msgid "`set manipulation`_"
msgstr "`set manipulation`_ 参照"

#: ../../topics/selectors.rst:732
msgid "Regular expressions"
msgstr "正規表現"

#: ../../topics/selectors.rst:734
msgid ""
"The ``test()`` function, for example, can prove quite useful when XPath's"
" ``starts-with()`` or ``contains()`` are not sufficient."
msgstr "たとえば、 ``test()`` 関数は、XPathの ``starts-with()`` または ``contains()`` が十分でない場合に非常に便利です。"

#: ../../topics/selectors.rst:737
msgid ""
"Example selecting links in list item with a \"class\" attribute ending "
"with a digit::"
msgstr "数字で終わるクラス属性を持つリスト項目内のリンクを選択する例::"

#: ../../topics/selectors.rst:758
msgid ""
"C library ``libxslt`` doesn't natively support EXSLT regular expressions "
"so `lxml`_'s implementation uses hooks to Python's ``re`` module. Thus, "
"using regexp functions in your XPath expressions may add a small "
"performance penalty."
msgstr "Cライブラリ ``libxslt`` はEXSLT正規表現をネイティブにサポートしていないため、 `lxml`_ の実装はPythonの ``re`` モジュールへのフックを使用します。 したがって、XPath式で正規表現関数を使用すると、パフォーマンスが若干低下する可能性があります。"

#: ../../topics/selectors.rst:764
msgid "Set operations"
msgstr "組(set)の操作"

#: ../../topics/selectors.rst:766
msgid ""
"These can be handy for excluding parts of a document tree before "
"extracting text elements for example."
msgstr "これらは、たとえばテキスト要素を抽出する前にドキュメントツリーの一部を除外するのに便利です。"

#: ../../topics/selectors.rst:769
msgid ""
"Example extracting microdata (sample content taken from "
"http://schema.org/Product) with groups of itemscopes and corresponding "
"itemprops::"
msgstr "アイテムスコープのグループと対応するitempropを使用してmicrodata(http://schema.org/Productから取得したサンプルコンテンツ)を抽出する例::"

#: ../../topics/selectors.rst:854
msgid ""
"Here we first iterate over ``itemscope`` elements, and for each one, we "
"look for all ``itemprops`` elements and exclude those that are themselves"
" inside another ``itemscope``."
msgstr "ここでは、まず ``itemscope`` 要素を反復処理し、各要素について、すべての ``itemscope`` 要素を探し、別の ``itemscope`` 内にある要素を除外します。"

#: ../../topics/selectors.rst:863
msgid "Other XPath extensions"
msgstr "その他のXPath拡張機能"

#: ../../topics/selectors.rst:865
msgid ""
"Scrapy selectors also provide a sorely missed XPath extension function "
"``has-class`` that returns ``True`` for nodes that have all of the "
"specified HTML classes."
msgstr "Scrapyセレクターは、指定されたすべてのHTMLクラスを持つノードに対して ``True`` を返す、非常に間違ったXPath拡張関数 ``has-class`` も提供します。"

#: ../../topics/selectors.rst:871
msgid "For the following HTML::"
msgstr "次のHTMLの場合::"

#: ../../topics/selectors.rst:880
msgid "You can use it like this::"
msgstr "あなたは以下のように使用できます::"

#: ../../topics/selectors.rst:890
msgid ""
"So XPath ``//p[has-class(\"foo\", \"bar-baz\")]`` is roughly equivalent "
"to CSS ``p.foo.bar-baz``.  Please note, that it is slower in most of the "
"cases, because it's a pure-Python function that's invoked for every node "
"in question whereas the CSS lookup is translated into XPath and thus runs"
" more efficiently, so performance-wise its uses are limited to situations"
" that are not easily described with CSS selectors."
msgstr "XPath ``//p[has-class(\"foo\", \"bar-baz\")]`` は、CSS ``p.foo.bar-baz`` とほぼ同等です。 CSS探索はXPathに変換されてより効率的に実行されるのに対し、これは問題のすべてのノードに対して呼び出される純粋なPython関数であるため、ほとんどの場合は、CSSセレクターではありえないぐらい遅いことに注意してください。"

#: ../../topics/selectors.rst:897
msgid "Parsel also simplifies adding your own XPath extensions."
msgstr "また、Parselは、独自のXPath拡張機能の追加も簡単にします。"

#: of parsel.xpathfuncs.set_xpathfunc:1
msgid "Register a custom extension function to use in XPath expressions."
msgstr "XPath式で使用するカスタム拡張機能を登録します。"

#: of parsel.xpathfuncs.set_xpathfunc:3
msgid ""
"The function ``func`` registered under ``fname`` identifier will be "
"called for every matching node, being passed a ``context`` parameter as "
"well as any parameters passed from the corresponding XPath expression."
msgstr "``fname`` 識別子の下に登録された関数 ``func`` は、一致するすべてのノードに対して呼び出され、 ``context`` パラメーターだけでなく、対応するXPath式から渡されたパラメーターが渡されます。"

#: of parsel.xpathfuncs.set_xpathfunc:7
msgid "If ``func`` is ``None``, the extension function will be removed."
msgstr "``func`` が ``None`` の場合、拡張関数は削除されます。"

#: of parsel.xpathfuncs.set_xpathfunc:9
msgid "See more `in lxml documentation`_."
msgstr "詳細は `in lxml documentation`_ を参照してください。"

#: ../../topics/selectors.rst:905
msgid "Built-in Selectors reference"
msgstr "組み込みセレクタリファレンス"

#: ../../topics/selectors.rst:911
msgid "Selector objects"
msgstr "セレクター・オブジェクト"

#: of scrapy.selector.Selector:1
msgid ""
"An instance of :class:`Selector` is a wrapper over response to select "
"certain parts of its content."
msgstr ":class:`Selector` のインスタンスは、コンテンツの特定の部分を選択するためのレスポンスのラッパーです。"

#: of scrapy.selector.Selector:4
msgid ""
"``response`` is an :class:`~scrapy.http.HtmlResponse` or an "
":class:`~scrapy.http.XmlResponse` object that will be used for selecting "
"and extracting data."
msgstr "``response`` は :class:`~scrapy.http.HtmlResponse` または :class:`~scrapy.http.XmlResponse` オブジェクトで、データの選択と抽出に使用されます。"

#: of scrapy.selector.Selector:8
msgid ""
"``text`` is a unicode string or utf-8 encoded text for cases when a "
"``response`` isn't available. Using ``text`` and ``response`` together is"
" undefined behavior."
msgstr "``text`` は ``response`` が利用できない場合のためのUnicode文字列またはutf-8エンコードされたテキストです。 ``text`` と ``response`` を一緒に使用することは未定義の動作です。"

#: of scrapy.selector.Selector:12
msgid ""
"``type`` defines the selector type, it can be ``\"html\"``, ``\"xml\"`` "
"or ``None`` (default)."
msgstr "``type`` はセレクターのタイプを定義します。これは ``\"html\"`` または ``\"xml\"`` または ``None`` (デフォルト)です。"

#: of scrapy.selector.Selector:15
msgid ""
"If ``type`` is ``None``, the selector automatically chooses the best type"
" based on ``response`` type (see below), or defaults to ``\"html\"`` in "
"case it is used together with ``text``."
msgstr "``type`` が ``None`` の場合、セレクターは ``response`` タイプ(下記参照)に基づいて最適なタイプを自動的に選択するか、 ``text`` と一緒に使用される場合はデフォルトで ``\"html\"`` になります。"

#: of scrapy.selector.Selector:19
msgid ""
"If ``type`` is ``None`` and a ``response`` is passed, the selector type "
"is inferred from the response type as follows:"
msgstr "``type`` の内容が ``None`` である ``response`` が渡された場合、セレクタータイプは応答タイプから次のように推測されます:"

#: of scrapy.selector.Selector:22
msgid "``\"html\"`` for :class:`~scrapy.http.HtmlResponse` type"
msgstr ":class:`~scrapy.http.HtmlResponse` タイプの場合は ``\"html\"``"

#: of scrapy.selector.Selector:23
msgid "``\"xml\"`` for :class:`~scrapy.http.XmlResponse` type"
msgstr ":class:`~scrapy.http.XmlResponse` タイプの場合は ``\"xml\"``"

#: of scrapy.selector.Selector:24
msgid "``\"html\"`` for anything else"
msgstr "その他の場合は ``\"html\"``"

#: of scrapy.selector.Selector:26
msgid ""
"Otherwise, if ``type`` is set, the selector type will be forced and no "
"detection will occur."
msgstr "それ以外の場合、 ``type`` が設定されていると、セレクターのタイプは強制され、検出は行われません。"

#: of scrapy.selector.Selector.xpath:1
msgid ""
"Find nodes matching the xpath ``query`` and return the result as a "
":class:`SelectorList` instance with all elements flattened. List elements"
" implement :class:`Selector` interface too."
msgstr "xpath ``query`` に一致するノードを見つけ、すべての要素がフラット化された :class:`SelectorList` インスタンスとして結果を返します。 リスト要素は :class:`Selector` インターフェースも実装しています。"

#: of scrapy.selector.Selector.xpath:5
msgid "``query`` is a string containing the XPATH query to apply."
msgstr "``query`` は、適用するXPATHクエリを含む文字列です。"

#: of scrapy.selector.Selector.xpath:7 scrapy.selector.SelectorList.xpath:6
msgid ""
"``namespaces`` is an optional ``prefix: namespace-uri`` mapping (dict) "
"for additional prefixes to those registered with "
"``register_namespace(prefix, uri)``. Contrary to "
"``register_namespace()``, these prefixes are not saved for future calls."
msgstr "``namespaces`` はオプションの ``prefix: namespace-uri`` マッピング(辞書)であり、これは ``register_namespace(prefix, uri)`` で登録されたプレフィックスに追加されます。 ``register_namespace()`` とは逆に、これらのプレフィックスは将来の呼び出しのために保存されません。"

#: of scrapy.selector.Selector.xpath:12 scrapy.selector.SelectorList.xpath:11
msgid ""
"Any additional named arguments can be used to pass values for XPath "
"variables in the XPath expression, e.g.::"
msgstr "任意の追加の名前付き引数を使用して、XPath式内のXPath変数の値を渡すことができます。例::"

#: ../../topics/selectors.rst:919
msgid "For convenience, this method can be called as ``response.xpath()``"
msgstr "便宜上、このメソッドは ``response.xpath()`` として呼び出すことができます"

#: of scrapy.selector.Selector.css:1
msgid "Apply the given CSS selector and return a :class:`SelectorList` instance."
msgstr "指定のCSSセレクターを適用し、 :class:`SelectorList` インスタンスを返します。"

#: of scrapy.selector.Selector.css:3
msgid "``query`` is a string containing the CSS selector to apply."
msgstr "``query`` は、適用するCSSセレクターを含む文字列です。"

#: of scrapy.selector.Selector.css:5
msgid ""
"In the background, CSS queries are translated into XPath queries using "
"`cssselect`_ library and run ``.xpath()`` method."
msgstr "バックグラウンドで、CSSクエリは `cssselect`_ ライブラリを使用してXPathクエリに変換され、 ``.xpath()`` メソッドを実行します。"

#: ../../topics/selectors.rst:925
msgid "For convenience, this method can be called as ``response.css()``"
msgstr "便宜上、このメソッドは ``response.css()`` として呼び出すことができます"

#: of scrapy.selector.Selector.get:1
msgid ""
"Serialize and return the matched nodes in a single unicode string. "
"Percent encoded content is unquoted."
msgstr "単一のUnicode文字列で一致したノードをシリアル化して返します。 パーセント文字でエンコードされたコンテンツは引用符で囲まれていません。"

#: ../../topics/selectors.rst:929 ../../topics/selectors.rst:961
#: ../../topics/selectors.rst:965
msgid "See also: :ref:`old-extraction-api`"
msgstr ":ref:`old-extraction-api` も参照下さい。"

#: of scrapy.selector.Selector.attrib:1
msgid "Return the attributes dictionary for underlying element."
msgstr "基になる要素の属性辞書を返します。"

#: of scrapy.selector.Selector.re:1
msgid ""
"Apply the given regex and return a list of unicode strings with the "
"matches."
msgstr "与えられた正規表現を適用し、一致するUnicode文字列のリストを返します。"

#: of scrapy.selector.Selector.re:4
msgid ""
"``regex`` can be either a compiled regular expression or a string which "
"will be compiled to a regular expression using ``re.compile(regex)``."
msgstr "``regex`` は、コンパイル済みの正規表現、または ``re.compile(regex)`` を使用して正規表現にコンパイルされる文字列のいずれかです。"

#: of scrapy.selector.Selector.re:7 scrapy.selector.Selector.re_first:5
msgid ""
"By default, character entity references are replaced by their "
"corresponding character (except for ``&amp;`` and ``&lt;``). Passing "
"``replace_entities`` as ``False`` switches off these replacements."
msgstr "デフォルトでは、文字エンティティ参照は対応する文字に置き換えられます(``&amp;`` と ``&lt;`` を除く)。 ``replace_entities`` を ``False`` にして渡すと、これらの置換がオフになります。"

#: of scrapy.selector.Selector.re_first:1
msgid ""
"Apply the given regex and return the first unicode string which matches. "
"If there is no match, return the default value (``None`` if the argument "
"is not provided)."
msgstr "与えられた正規表現を適用し、一致する最初のUnicode文字列を返します。 一致するものがない場合、デフォルト値を返します(引数が指定されていない場合は ``None`` )。"

#: of scrapy.selector.Selector.register_namespace:1
msgid ""
"Register the given namespace to be used in this :class:`Selector`. "
"Without registering namespaces you can't select or extract data from non-"
"standard namespaces. See :ref:`selector-examples-xml`."
msgstr "この :class:`Selector` で使用する、与えられた名前空間を登録します。 名前空間を登録しないと、非標準の名前空間からデータを選択または抽出できません。 :ref:`selector-examples-xml` を参照してください。"

#: of scrapy.selector.Selector.remove_namespaces:1
msgid ""
"Remove all namespaces, allowing to traverse the document using namespace-"
"less xpaths. See :ref:`removing-namespaces`."
msgstr "すべての名前空間を削除し、名前空間のないxpathを使用してドキュメントを走査できるようにします。 :ref:`removing-namespaces` を参照してください。"

#: of scrapy.selector.Selector.__bool__:1
msgid ""
"Return ``True`` if there is any real content selected or ``False`` "
"otherwise.  In other words, the boolean value of a :class:`Selector` is "
"given by the contents it selects."
msgstr "実際のコンテンツが選択されている場合は ``True`` を返し、そうでない場合は ``False`` を返します。 言い換えれば、 :class:`Selector` のブール値は、選択するコンテンツによって与えられます。"

#: of scrapy.selector.Selector.getall:1
msgid ""
"Serialize and return the matched node in a 1-element list of unicode "
"strings."
msgstr "ユニコード文字列の1要素リストで一致したノードをシリアル化して返します。"

#: ../../topics/selectors.rst:947
msgid ""
"This method is added to Selector for consistency; it is more useful with "
"SelectorList. See also: :ref:`old-extraction-api`"
msgstr "このメソッドは、一貫性のためにセレクタに追加されます。 SelectorListの方が便利です。 :ref:`old-extraction-api` 参照。"

#: ../../topics/selectors.rst:951
msgid "SelectorList objects"
msgstr "SelectorListオブジェクト"

#: of scrapy.selector.SelectorList:1
msgid ""
"The :class:`SelectorList` class is a subclass of the builtin ``list`` "
"class, which provides a few additional methods."
msgstr ":class:`SelectorList` クラスは組み込みの ``list`` クラスのサブクラスであり、いくつかの追加メソッドを提供します。"

#: of scrapy.selector.SelectorList.xpath:1
msgid ""
"Call the ``.xpath()`` method for each element in this list and return "
"their results flattened as another :class:`SelectorList`."
msgstr "このリストの各要素に対して ``.xpath()`` メソッドを呼び出し、別の :class:`SelectorList` としてフラット化された結果を返します。"

#: of scrapy.selector.SelectorList.xpath:4
msgid "``query`` is the same argument as the one in :meth:`Selector.xpath`"
msgstr "``query`` は :meth:`Selector.xpath` のそれと同じです"

#: of scrapy.selector.SelectorList.css:1
msgid ""
"Call the ``.css()`` method for each element in this list and return their"
" results flattened as another :class:`SelectorList`."
msgstr "このリストの各要素に対して ``.css()`` メソッドを呼び出し、結果を別の :class:`SelectorList` としてフラット化して返します。"

#: of scrapy.selector.SelectorList.css:4
msgid "``query`` is the same argument as the one in :meth:`Selector.css`"
msgstr "``query`` は :meth:`Selector.css` のそれと同じです"

#: of scrapy.selector.SelectorList.getall:1
msgid ""
"Call the ``.get()`` method for each element is this list and return their"
" results flattened, as a list of unicode strings."
msgstr "このリストの各要素に対して ``.get()`` メソッドを呼び出し、その結果をユニコード文字列のリストとしてフラット化して返します。"

#: of scrapy.selector.SelectorList.get:1
msgid ""
"Return the result of ``.get()`` for the first element in this list. If "
"the list is empty, return the default value."
msgstr "このリストの最初の要素に対して ``.get()`` の結果を返します。 リストが空の場合、デフォルト値を返します。"

#: of scrapy.selector.SelectorList.re:1
msgid ""
"Call the ``.re()`` method for each element in this list and return their "
"results flattened, as a list of unicode strings."
msgstr "このリストの各要素に対して ``.re()`` メソッドを呼び出し、その結果をユニコード文字列のリストとしてフラット化して返します。"

#: of scrapy.selector.SelectorList.re:4 scrapy.selector.SelectorList.re_first:6
msgid ""
"By default, character entity references are replaced by their "
"corresponding character (except for ``&amp;`` and ``&lt;``. Passing "
"``replace_entities`` as ``False`` switches off these replacements."
msgstr "デフォルトでは、文字実体参照は対応する文字に置き換えられます(``&amp;`` と ``&lt;`` を除きます)。 ``replace_entities`` を ``False`` として渡すと、これらの置き換えがオフになります。"

#: of scrapy.selector.SelectorList.re_first:1
msgid ""
"Call the ``.re()`` method for the first element in this list and return "
"the result in an unicode string. If the list is empty or the regex "
"doesn't match anything, return the default value (``None`` if the "
"argument is not provided)."
msgstr "このリストの最初の要素に対して ``.re()`` メソッドを呼び出して、結果をUnicode文字列で返します。 リストが空であるか、正規表現が何とも一致しない場合、デフォルト値を返します(引数が指定されていない場合は ``None`` )。"

#: of scrapy.selector.SelectorList.attrib:1
msgid ""
"Return the attributes dictionary for the first element. If the list is "
"empty, return an empty dict."
msgstr "最初の要素の属性辞書を返します。 リストが空の場合、空の辞書を返します。"

#: ../../topics/selectors.rst:978
msgid "Examples"
msgstr "例"

#: ../../topics/selectors.rst:983
msgid "Selector examples on HTML response"
msgstr "HTMLレスポンスのSelectorの例"

#: ../../topics/selectors.rst:985
msgid ""
"Here are some :class:`Selector` examples to illustrate several concepts. "
"In all cases, we assume there is already a :class:`Selector` instantiated"
" with a :class:`~scrapy.http.HtmlResponse` object like this::"
msgstr "ここで、いくつかの概念を説明するため :class:`Selector` の例を示します。すべての場合において、このような :class:`~scrapy.http.HtmlResponse` オブジェクトでインスタンス化された :class:`Selector` が既に存在すると仮定します::"

#: ../../topics/selectors.rst:991
msgid ""
"Select all ``<h1>`` elements from an HTML response body, returning a list"
" of :class:`Selector` objects (ie. a :class:`SelectorList` object)::"
msgstr "HTMLレスポンス・ボディのすべての ``<h1>`` 要素を選択し、 :class:`Selector`  オブジェクトのリスト(つまり、 :class:`SelectorList` オブジェクト)を返します::"

#: ../../topics/selectors.rst:996
msgid ""
"Extract the text of all ``<h1>`` elements from an HTML response body, "
"returning a list of unicode strings::"
msgstr "HTMLレスポンス・ボディのすべての ``<h1>`` 要素のテキストを抽出し、Unicode文字列のリストを返します::"

#: ../../topics/selectors.rst:1002
msgid "Iterate over all ``<p>`` tags and print their class attribute::"
msgstr "すべての ``<p>`` タグを反復処理し、それらのクラス属性を出力します::"

#: ../../topics/selectors.rst:1011
msgid "Selector examples on XML response"
msgstr "XMLレスポンスでのSelector例"

#: ../../topics/selectors.rst:1013
msgid ""
"Here are some examples to illustrate concepts for :class:`Selector` "
"objects instantiated with an :class:`~scrapy.http.XmlResponse` object::"
msgstr ":class:`~scrapy.http.XmlResponse` オブジェクトでインスタンス化された :class:`Selector` オブジェクトの概念を説明するための例をいくつか示します::"

#: ../../topics/selectors.rst:1018
msgid ""
"Select all ``<product>`` elements from an XML response body, returning a "
"list of :class:`Selector` objects (ie. a :class:`SelectorList` object)::"
msgstr "XMLレスポンス・ボディのすべての ``<product>`` 要素を選択し、 :class:`Selector` オブジェクトのリスト(つまり、 :class:`SelectorList` オブジェクト)を返します::"

#: ../../topics/selectors.rst:1023
msgid ""
"Extract all prices from a `Google Base XML feed`_ which requires "
"registering a namespace::"
msgstr "名前空間の登録が必要な `Google Base XML feed`_  からすべての価格を抽出します::"

